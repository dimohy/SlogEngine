@using SlogEngine.WebAssembly.Models
@inject IJSRuntime JSRuntime

<div class="modal-overlay" @onclick="CloseModal">
    <div class="modal-content" @onclick:stopPropagation="true">
        <div class="modal-header">
            <h3>@Title</h3>
            <button class="modal-close" @onclick="CloseModal">&times;</button>
        </div>
        <div class="modal-body">
            @ChildContent
        </div>
        @if (ShowActions)
        {
            <div class="modal-actions">
                <button class="custom-btn secondary" @onclick="CloseModal">@CancelText</button>
                <button class="custom-btn primary" @onclick="Confirm">@ConfirmText</button>
            </div>
        }
    </div>
</div>

@code {
    [Parameter] public string Title { get; set; } = "Modal";
    [Parameter] public bool ShowActions { get; set; } = true;
    [Parameter] public string CancelText { get; set; } = "취소";
    [Parameter] public string ConfirmText { get; set; } = "확인";
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnConfirm { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // 모달이 열릴 때 body의 스크롤을 비활성화하고 modal-open 클래스 추가
            await JSRuntime.InvokeVoidAsync("eval", "document.body.style.overflow = 'hidden'; document.body.classList.add('modal-open');");
        }
    }

    private async Task CloseModal()
    {
        // 모달이 닫힐 때 body의 스크롤을 복원하고 modal-open 클래스 제거
        await JSRuntime.InvokeVoidAsync("eval", "document.body.style.overflow = ''; document.body.classList.remove('modal-open');");
        await OnClose.InvokeAsync();
    }

    private async Task Confirm()
    {
        // 모달이 닫힐 때 body의 스크롤을 복원하고 modal-open 클래스 제거
        await JSRuntime.InvokeVoidAsync("eval", "document.body.style.overflow = ''; document.body.classList.remove('modal-open');");
        await OnConfirm.InvokeAsync();
    }
}
